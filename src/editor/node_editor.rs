
// Messages are generated by the ui and go to the handlers
// Handlers generate actions which are sent to the store (actions are cached and have an inverse)
// Handlers generate responses which go back to the ui
// UI receives responses and is updated

use std::collections::VecDeque;

use tuix::*;

use super::{EditorAction, EditorData, tool::*};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum EditorMessage {
    PressedNode(Entity),
    ReleasedNode(Entity),
    PressedCanvas,
    MouseMove(f32, f32),
}
pub enum EditorResponse {
    NodeSelected(Entity),
    NodeDeselected(Entity),
}

struct NodeEditor {
    // Mapping from node path to corresponding ui entity
    //nodes: HashMap<NodePath, Entity>,
    selected_tool: Tool,
    select_tool_state: SelectToolState,

    data: EditorData,
    undo_list: Vec<EditorAction>,
    redo_list: Vec<EditorAction>,
}

impl NodeEditor {
    pub fn new() -> Self {
        Self {
            selected_tool: Tool::Select,

            select_tool_state: SelectToolState::SingleSelect,

            data: EditorData::default(),
            undo_list: Vec::new(),
            redo_list: Vec::new(),
        }
    }
}

impl Widget for NodeEditor {
    type Ret = Entity;
    fn on_build(&mut self, state: &mut State, entity: Entity) -> Self::Ret {
        entity
    }

    fn on_event(&mut self, state: &mut State, entity: Entity, event: &mut Event) {
        if let Some(node_editor_message) = event.message.downcast::<EditorMessage>() {
            // Create an empty batch of actions
            let mut actions = VecDeque::<EditorAction>::new();
            // Active tool processes messages and generates actions
            self.select_tool_state.transition(*node_editor_message, SelectToolData{}, &mut actions);
            // Editor store processes actions, mutates stored data, and then generates responses
            self.data.process_actions(&mut actions);
        }

        // if let Some(node_editor_reponse) = event.message.downcast() {

        // }
    }
}